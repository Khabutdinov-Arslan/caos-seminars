# Bash и регулярные выражения

В прошлый раз мы рассмотрели способ автоматизировать рутинные операции сборки: Make. Но понятно, что это не единственная предметная область, в которой можно что-то автоматизировать. С помощью скриптов можно настраивать окружение для разработки, http запросы для нагрузочного тестирования, чистить старые логи и автоматизировать множество других вещей.

Сегодня мы поговорим о bash. Это скриптовый язык, который доступен из коробки в большинстве UNIX (и не только) систем. Терминал этих систем является интерактивной оболочкой над ним. Файлы со скриптами обычно имеют расширение ``sh``.

Скорее всего вы уже знакомы с другим скриптовым языком -- Python. Может сразу возникнуть закономерный вопрос, когда лучше использовать bash. По моему опыту он удобен, когда нужно написать некоторую обвязку над стандартными утилитами по типу ``head``, ``ls``, ``grep``. В остальных случаях я предпочитаю сразу писать на Python.

## Команды

Вы уже наверняка сталкивались с терминалом в прошлых курсах и пользовались, например, командой ``ls``. На самом деле, есть два типа команд: встроенные в интерпретатор и внешние. К первым относится, например, ``cd`` (список всех таких команд можно посмотреть в ``man builtins``), ко вторым ``ls``. Внешние программы ищутся по порядку по путям, перечисленным в глобальной переменной ``$PATH``.

> Если вы хотите понять, где конкретно находится конкретный файл, можно воспользоваться командой ``which``.
> Например: ``which whoami``.
> Большинство известных вам стандартных утилит находятся в ``/usr/bin``.

С точки зрения расширяемости было бы логично реализовать все команд, однако у этого подхода есть несколько проблем:

* Запуск внешних программ медленнее
* Внешние команды не могут повлиять на внутреннее состояние командной оболочки

## Базовый синтаксис

Bash скрипты обычно принято писать в файлах с расширением ``.sh``. Как и в случае других скриптовых языков, чтобы запускать скрипт через ``./script_name``, нужно не забыть сделать две вещи:

* Указать в начале файла путь к интерпретатору языка. В нашем случае это ``#!/usr/bin/bash``
* Сделать файл исполняемым. Например с помощью команды ``chmod +x script_name``.

## Переменные

* Объявить переменную: ``foo=bar``. По умолчанию все переменные глобальные и доступны с момента объявления. ``local foo=bar`` позволяет объявить локальную переменную (полезно, например, внутри функции)
* Получить значение: ``$foo``. Можно подставить значение в строку, но тогда она должна быть заключена в двойные кавычки (например, ``echo "Score: $score``).
* Записать результат команды в переменную: ``foo=$(command)``. 

> Нельзя ставить пробелы вокруг знако арифметических операций, потому что с точки зрения интерпретатора это будет вызов команды `foo` с аргументами `=` и `bar`.

В качестве примера использования переменных можно посмотреть на скрипт ``greet_me.sh``.

В случае массивов:

* Объявление: ``$foo=(alex ivan vasya)``
* Количество элементов: ``${#foo[@]}``
* Доступ по индексу: ``${foo[$i]}``

## Аргументы

Аргументы скрипта принято разделять пробелами. Если аргумент содержит пробел, можно заключить его в кавычки целиком, или поставить `\` непосредственно перед пробелом, чтобы его экранировать. Обычные аргументы называются позиционными, бывают ещё опциональные, их имена начинаются с `-` или ``--``.

Возьмём для примера команду ``ls -l dir_name``. Здесь ``dir_name`` позиционный аргумент, а ``-l`` опциональный.

С аргументами можно работать следующим образом:

* ``$0..$9`` получить аргумент по номеру, в ``$0`` будет лежать имя скрипта.
* ``$#`` получить количество аргументов
* ``$@`` получить список аргументов.

Теперь мы можем поприветсовать пользователя, который передаст нам своё имя (см. ``greet_one.sh``).

## Циклы

Основной способ объявления цикла выглядит следующим образом:

```
for item in list
do
    commands
done
```

Обычно подразумевается, что элементы списка разделены пробельными символами, но можно переопределить  символ разделителя, с помощью конструкции ``IFS=:``.

Вооружившись этим знанием, можем научиться приветствовать нескольких людей (см. ``greet_many.c``).

Классический вариант с числами, можно сделать с помощью генератора списка ``{from..to..step}``, ну или просто воспользоваться альтернативным синтаксисом (но это будет работать только в ``bash`` и ``zsh``).

```
for (( i=0; i<10; i++ ))
do
   echo "$i"
done
```

Цикл ``while`` также существует:

```
while condition
do
    commands
done
```

## Условия

Условия объявляются с помощью ``[[ condition ]]`` (пробелы важны, потому что ``[[`` это на самом деле имя команды).

Можно использовать:
* Сравнения чисел: ``[[ $x -eq $y ]]``. (также доступны ``-lt``, ``-ne`` и т. д.).
* Сравнения строк: ``[[ $str1=$str2 ]]``
* Проверку на пустоту строк ``[[ -z $str ]]`` (``-n`` непустоту)
* Логические операторы: ``[[ $cond1&&$cond2 ]]``
* Существование пути: ``[[ -e filename ]]`` (``-f`` обычный файл, ``-d`` директория, ``-e`` исполняемый)

> А вот здесь можно заметить пробел после квадратных скобок. Внимательный читатель поймёт, что ``[[`` это на самом деле команда.
> Подробнее про неё почитать тут: http://mywiki.wooledge.org/BashFAQ/031

Синтаксис ветвлений:

```
if condition; then
    commands
else
    commands
fi
```

## Функции

В Bash можно также объявлять функции. 

```
function f() {

}
```

Сразу возникает вопрос, как объявлять аргументы. На самом деле никак, а обращение к ним аналогично
обращению к аргументам скрипта. А возврат значения из функции производится командой `echo`. 

Как и в случае команд, вызов функции выглядит как `$(function _name args)`. Eсли вам не нужно возвращаемое значение, можно просто писать ``function_name args``), тогда ``echo`` внутри функции будет выводить значения в консоль.

> Если в функции есть несколько `echo`, их вывод склеивается через пробел в одну строку.

Пример использования функций можно посмотреть в `greet_function.c`.

## Перенаправление ввода/вывода

С помощью `<` можно перенаправить ввод, с помощью `>` вывод (если хотите игнорировать вывод команды, можно перенаправить его в специальный файл ``/dev/null``). Можно в этом синтаксисе явно указывать номер файлового дескриптора, который вы хотите перенаправить (по умолчанию `1`, что обычно `stdout`), например `2>/dev/null` перенаправит в никуда стандартный поток ошибок (а можно написать `&>/dev/null` и перенаправить оба потока сразу). `|` позволяет перенаправить вывод команды на ввод следующей. 

Например: `cat greet_one.c  | wc`.

Таким образом можно выстраивать произвольно длинные цепочки.

Ещё можно выстраивать цепочки из логических операторов. Результат исполнения команды считается за `true`, если она завершилась с кодом 0. С учётом того, что логические операторы вычисляются лениво, получаем следующее:

* `cmd1 && cmd2` - `cmd2` будет выполнена, если `cmd1` выполнена успешно, а итоговый результат - это код возврата `cmd2`;
* `cmd1 || cmd2` - `cmd2` будет выполнена, если не удалось успешно выполнить `cmd1`, результат - либо значение 0, либо код возврата `cmd2`.

Демонстрацию можно посмотреть в `logic.sh`.

## Арифметика

Сам по себе bash умеет только в знаковую целочисленную арифметику, поэтому автор не использует писать на нём скрипты для каких-либо рассчётов. Однако существует консольная утилита `bc` (флаг `-l` нужен для расширенного синтаксиса), которая в состоянии вычислять более сложные выражения. Воспользовавшись знаниями из прошлого пункта, можно получить такую конструкцию:

``echo '(1+3)*2' | bc -l``

## Чтение 

Чтобы построчно считывать из консоли, можно использовать команду `read`.

```
while read entry
do
    commands
done
```

## Регулярные выражения

Регулярные выражения это удобный способ работы со строками с помощью шаблонов. Разобрать синтаксис и поиграться с ними на мой взгляд удобнее в интерактиной среде (см. `regex.ipynb`).

Можно запустить colab'е, если так удобнее: https://colab.research.google.com/drive/1TR5Dfq1dVEKbnI30GnzrSjv-O4-LWgOr

## grep

Утилита `grep` выводит строки, в которых содержится шаблон. Полезно всегда использовать опцию ``-E``, включающую расширенный синтаксис.

* Поискать в одном файле ``grep -E greet README.md``
* Поискать в текущей папке и всех вложенных ``grep -E -r greet``

В жизни часто вам нужно будет искать по логам. Несколько полезных опций на этот случай:

* `-n` печатать номера строк
* `-A count` (`-B count`) печатать `count` строк до/после совпадения
* `-i` игнорировать регистр
* `-v` вернуть не совпадающие строки

## sed

`grep` позволяет построчно искать в файлах.

Если же мы хотим что-то поменять (опять же, что важно, построчно), нужно использовать `sed`.

Самый популярный сценарий использования -- замена одной строки на другую.

``sed 's/from/to/'``

Заменить только первое вхождение в строку. Чтобы заменить все, нужно добавить флаг `g` (``sed 's/from/to/g'``).

> Стоит заметить, что как и большинство стандартных команд, `sed` по-умолчанию
использует стандартные потоки ввода-вывода. Если хочется поменять файл `sed -i filename 's/from/to'`, `-i` здесь отвечает за то, что будет изменён исходный файл.

Группы захвата выделяются скобками, их нужно экранировать. Обратиться к содержимому группы захвата можно через `\index`.

``echo 'track0 is playing' | sed 's/.*\(track[0-9]\).*/\1/'``


* `-n` отключить вывод строк по-умолчанию
* `/p` выводить строки, в которых есть вхождения
* `/d` удалять строки, в которых есть вхождения
* `!` обратить действие (`/!d` не выводить строки, в которых есть вхождения)

То есть ``sed -n '/regex/p`` по сути будет являться аналогом `grep`.

Можно применять команды к определённому набору строк:

``echo 'track0 album0' | sed '1 s/\(track[0-9]\).*/\1/'``

Возможные диапазоны (нумерация с единицы):

* `line_number` применить к одной строке с номером `line_number`
* `line_from,line_to` применить к строкам с номерами от `line_from` до `line_to`
* `line_from,$` применить к строкам с номерами от `line_from` до последней

Это всё, что вам понадобится, подробнее можно почитать в https://www.grymoire.com/Unix/Sed.html.
