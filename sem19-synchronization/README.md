# Многопоточная синхронизация

Операции чтения и записи с традиционными типами не являются атомарными. То есть тот же инкремент с точки зрения ассемблера выглядит как-то так.

``
ldr rax, rsp
inc rax
mov rsp, rax
``

А что если мы делаем инкремент из двух потоков? Мы можем в обоих потоках сначала прочитать значение, а потом записать. Тогда мы увеличиваем значение только на 1, а не на 2, как должны были. Состояние, когда два потока обращаются одновремененно к ячейке памяти и хотя бы одна из них пищущая, называется гонкой (data race). Позапускав `no_sync.c`, можно увидеть, что сумма получается разной, то есть поведение не определено. Хочется такого избежать.

## Mutex

Будем называть критической секцией кусок куда, в котором одновременно должно находиться не более одного потока. Одним из способов организации является взятие блокировки на мьютексе. Одновременно мьютекс (от mutual excluson) может быть захвачен не более чем одним потоком, остальные потоки блокируются на этапе взятия mutex'а. 

Mutex объявлен в `pthread` и прредоставляет следующий `API`.

```
 * `pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)` - инициализация мьютекса для его последующего использования.
 * `pthread_mutex_destroy(pthread_mutex_t *mutex)` - уничтожить ранее созданный мьютекс.
 * `pthread_mutex_lock(pthread_mutex_t *mutex)` - захватить мьютекс. Если другой поток уже захватил его, то текущий поток приостанавливает свою работу.
 * `pthread_mutex_trylock(pthread_mutex_t *mutex)` - пытается захватить мьютекс. В случае успеха возвращает значение `0`, а если мьютекс уже занят, то значение `EBUSY`.
 * `pthread_mutex_unlock(pthread_mutex_t *mutex)` - освободить ранее захваченный мьютекс. В отличии от семафоров, освободить мьютекс может только тот поток, которые его захватил, в противном случае это приведет к ошибке `EPERM`.
```

Чтобы избежать гонок, можно обрамить обращения к разделяемым переменным взятием блокировки (см. `mutex.c`).

## Condvar

Можно заметить, что пока один поток захватил mutex, остальные его ждут и простаивают. Это не очень эффективно, хотелось бы уметь усыплять такие потоки и будить при освобождение mutex'а. Это можно сделать с помощью механизма условных переменных, которые связываются с mutex'ом.

* `pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *attr)` - инициализации условной переменной.
* `pthread_cond_destroy(pthread_cond_t *c)` - уничтожить условную переменную.
* `pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)` - ожидает нотификации условной переменной переменной `c`, временно разблокируя мютекс `m`. Перед вызовом мьютекс должен находиться в заблокированном состоянии, в противном случае - неопределенное поведение. После наступления события нотификации, мьютекс опять блокируется.
* `pthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m, const struct timespec *timeout)` - то же, что и `pthread_cond_wait`, но ожидание прекращается по истечению указанного периода времени.
* `pthread_cond_signal(pthread_cond_t *c)` - уведомляет один поток, для которого выполняется ожидание нотификации. В общем случае, поток выбирается случайным образом, если их несколько.
* `pthread_cond_broadcast(pthread_cond_t *c)` - уведомляет все потоки, для которых выполняется ожидание нотификации.

В связи с особенностями реализации механизма условных переменных, бывают ложные пробуждения, поэтому засыпать нужно обязательно в цикле (см. `condvar.c`).

## Атомарные переменные и неблокирующие структуры данных

Взятие блокировки -- дорогая операция сама по себе. Кроме того, пока блокировка взята, конкурирующие потоки простаивают. Это может сильно замедлять программу. 

Хочется научиться строить lock-free структуры данных. Строить мы их будем на основе атомарных переменных размером с машинное слово. Основной концепт в том, чтобы заранее подготовить новую голову (в случае стека) и потом атомарно сдвинуть на неё указатель.

Объявляются атомарные переменные с помощью спецификатора `_Atomic`. Атомарные объекты не подвержены гонкам. На обращениях к памяти к ним есть строги порядок (как он устроен, вам расскажут в следующем семестре).

```
_Atomic(int*) counter;
```

Для операции с атомарными типами есть следующие макросы:

 * `void atomic_store(T* object, T value)`,
 * `void atomic_store_explicit(T* object, T value, memory_order order)` - сохранить значение в атомарную переменную.
 * `T atomic_load(T* object)`,
 * `T atomic_load_explicit(T* object, memory_order order)` - загрузить значение из переменной.
 * `T atomic_exchange(T* object, T new_value)`,
 * `T atomic_exchange_explicit(T* object, T new_value, memory_order order)` - заменить значение и вернуть предыдущее.
 * `_Bool atomic_compare_exchange_strong(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_strong_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)`,
 * `_Bool atomic_compare_exchange_weak(T* object, T* expected, T new_value)`,
 * `_Bool atomic_compare_exchange_weak_explicit(T* object, T* expected, T new_value, memory_order success, memory_order failure)` - сравнить два значения, в случае их равенства - заменить на новое, в противном случае - записать в `expected` значение `object`.
 * `T atomic_fetch_MOD(T* object, T operand)`,
 * `T atomic_fetch_MOD_explicit(T* object, T operand, memory_order order)` - получить значение переменной, после чего - модифицировать её. `MOD` можеть быть:
  - `add` - инкремент
  - `sub` - декремент
  - `and` - поразрядное "и"
  - `or` - поразрядное "или"
  - `xor` - поразрядное "исключающее или".

Про модели памяти вам расскажут в последующих курсах, а сейчас нам понадобятся только арифметические операции, `load`, `store` и `CAS` (так принято сокращать `compare_exchange_strong`).
 
Пример использования можно посмотреть в `atomic.c`.
