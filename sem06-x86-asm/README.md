# Ассемблер x86_64

Поговорим об ассемблере для архитектуры x86_64. В отличии от ARM, x86_64 CISC архитектура, то есть набор команд сильно больше и кодируется различным числом байт. TODO: мотивация

Неплохой справочник команд можно найти [здесь](https://www.felixcloutier.com/x86/).

У x86_64 есть ещё и несколько видов синтаксиса. Наиболее близкий из них, Intel, включается с помощью следующей опции, которую надо написать в начало исходника:

```
.intel_syntax noprefix
```

## Регистры и соглашения о вызовах

В Linux предусмотрены следующие соглашения об использовании регистров:

| Регистры        | Назначение                                                   |
| --------------- | ------------------------------------------------------------ |
| `rax`   | возвращаемое значение функции         |
| `rdi, rsi, rdx, rcx, r8, r9` | аргументы функции |
| `rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11`  | временные регистры, для которые не гарантируется сохранение результата, если вызывать какую-либо функцию |
| `rbx, rsp, rbp, r12, r13, r14, r15` | регистры, для которых гарантируется, что вызываемая функция их не будет портить |
| `rbp`           | указатель на границу фрейма функции, обычно используется отладчиком |
| `rsp`      | указатель на вершину стека                                   |

Обращаться к младшим 32 битам можно заменяя `r` на `e` (например `eax`) в начале имени регистра или дописывая `d` в случае номерных (например `r13d`).

В отличии от ARM, для перегонки значений в оперативную память и обратно не нужны отдельне команды `LDR` и `STR`. Всё это умеет делать обычный `mov`.

`mov register [base + index * scale + offset]` служит аналогом `LDR`, аналогично получается аналог `STR` если переставить аргументы местами. Обратите внимание, что такой синтаксис крайне удобен для работы с массивами. Поэтому функция для получения элемента массива в `arr_get.S` имеет всего одну смысловую строку (в [ARM версии](https://github.com/Khabutdinov-Arslan/caos-seminars/blob/main/sem04-arm-asm-basics/arr_get.S) было 3). 

Для загрузки в регистры чисел меньшей размерности служат суффиксы. Например, `movsxd` позволяет загружать знаковые 32-битные числа.

## Арифметические команды

Общий вид команд: `CMD left, right` отвечает за операцию `left=right`. Например: `ADD r8, r9`. Для примера 

TODO: Список команд

## Метки и написание функций

Аналогично ARM можно создавать метки и использовать команду `cmp` для сравнения значений.

Для безусловного перехода служит команда `jmp`. Условные переходы `jz`, `jle` и так далее.

Переход по метке функции осуществляется командой `call label_name`, которая кладёт адрес возврата на стек, подменяет его на следующую команду после `call` и передаёт управление функции.

## Отладка

``for gdb set disassembly-flavor intel | layout asm | layout regs``

Показать gdb server + qemu?
