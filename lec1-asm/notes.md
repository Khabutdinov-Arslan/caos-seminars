# ASM 1

## Мотивация

Сегодня мы опустимся на более низкий уровень. До этого мы писали на `C` платформонезависимый (за редким исключением, кстати, каким) код. Сгенерировать по нему машинный код под конкретную архитектуру было задачей компилятора. Сегодня мы поговорим об ассемблере, языке, наиболее близком к машинному коду. На самом деле, это не язык, а семейство, потому что он платформо-зависимый. Мы будем говорить про x86_64-битный GNU Assembler, потому что большинство серверов всё ещё работают на x86 архитектуре.

Скорее всего, вам больше никогда в жизни не придётся писать на ассемблере. Однако, знание ассемблера помогает лучше понимать, как всё работает: от оптимизаций компилятора до переключения процессов в операционной системе.

## Память
Когда мы обсуждали адресное пространство процесса, мы выяснили, что в памяти лежат как данные программы, так и её машинный код. Процессор, однако, оперирует регистрами -- быстрыми (x1000 по скорости обращения) ячейками памяти, расположенными на самом процессоре. 

## Регистры

Очень быстрые 64-битные ячейки памяти на самом процессоре. 

* Регистры общего назначения: `rax, rbx, rcx, rdx, rsi, rdi, r-r15`
* Специальные: `rbp`, `rsp`, `rip`, `rflags`, ...

*Картинка с иерархией регистров*

## Операнды команд

* imm (immediate) - константы
* r (register) - регистр
* m (memory) - оперативная память

## AT&T Intel

Есть 2 разных синтаксиса: Intel и AT&T. Они отличаются синтаксически (например, порядком операндов). Мы будем в курсе использовать Intel, потому что он более лаконичный и похож на другие ассеблеры, например ARM.

```
add eax, 4 //Intel
addl $4, %eax //AT&T
```

## Работа с памятью

`mov dst, src`

Например, для загрузки значения в регистр из памяти: 
```
mov register [base + index * scale + offset]
```

Синтаксис очень удобен для обращения к массивам. Пусть в `rdi` лежит указатель на начало массива 64-битных чисел, а в `rsi` индекс элемента, который мы хотим загрузить в регистр `rax`. Это можно сделать так:

```
mov rax, [rdi + rsi * 8]
```

Ограничение: нельзя переложить из ячейки памяти в память.

Если мы хотим загрузить не значение, а адрес, можно использовать команду `lea`, синтаксис который аналогичен `mov`. Можно высчитывать адрес через арифметические команды, но `lea` лучше тем, что позволит посчитать адрес за одно действие, положить в произвольный регистр и не будет трогать флаги.

## Суффиксы команд

`movsxd` и прочее

## Арифметика

* Унарные операции, `op dst`: `inc`, `dec`, `neg`, `not`
* Бинарные операции, `op dst src`: `add`, `sub`, `imul`, `xor`, `or`, `and`

А как делить?
`idivq src` сохранит частное в `rax`, остаток в `rdx`.

## Флаги процессора

Некоторые инструкции (например `add`) могут менять флаги, которые хранятся в виде битов в служебном регистре `rflags`. Они содержат дополнительную информацию о результате операции. Основные флаги:

* `ZF` в результате операции получился `0`
* `SF` результат отрицательный
* `OF` знаковое переполнение
* `CF` беззнаковое переполнение

Инструкция `cmp` работает как `sub` выставляет только флаги и не меняет обычные регистры. 
Инструкция `test` аналогично работает как `and` но не трогает сами регистры.
Эти две инструкции обычно используются в условных переходах.

Примеры (для простоты будем рассуждать в терминах 4-битных чисел):

* `0x0001 - 0x0001 = 0x0000` (выставится `ZF`)
* `0x0000 - 0x0001 = 0x1111` (выставится `SF`)
* `0x1111 + 0x0001 = 0x0000` (выставится `CF`)
* `0x0111 + 0x001 = 0x1000` (выставится `OF`)

## Метки и переходы

В коде программы можно объявлять метки (`label_name:`).
Выполнение программы начинается с метки `main`.

`jmp label` безусловный переход

`jz` перейти при равенстве
Для знакомых чисел `jl`, `jle` и т. д.
Для беззнаковых чисел `jb`, `jbe` и т. д.

TODO: Слайды с отображениями while, if, for, switch.

## Стек

Локальные переменные выделяются на стеке. На его вершину указывает регистр `rsp`. Соответственно, чтобы выделить 64 бита, нужно сделать `sub rsp, 8`. В конце функции нужно не забыть вернуть `rsp` на место.

TODO: Картинка со стеком

Рассказать про `rbp`?

## Вызов функций

`call function_name` кладёт на стек адрес возврата и переходит в функцию.
`ret` забирает адрес возврата со стека и переходит по нему

* Первые 6 аргументов передаются в регистрах `rdi, rsi, rdx, rcx, r8, r9`, остальные на стеке. 
* Возвращается значение в `rax`

## Calling conventions

* При вызове функций вершин стека (`rsp`) должна быть выровнена по 16 байт
* Нужно сохранить значения `rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11`, если они вам нужны
* `rbx, rsp, rbp, r12, r13, r14, r15` нужно вернуть в неизменном виде после выхода из функции

## Векторные регистры

Для работы с плавающей точкой используются `SSE`, `AVX`, `AVX-512` регистры. Есть скалярные инструкции по типа `addsd dst, src`.

Векторные инструкции позволяют производить операцию над сразу несколькими значениями в одном регистре. Это может кратно ускорить программу. 

На ассемблере вы скорее всего писать не будете. Но intrinsics могут пригодиться вам для оптимизации кода на `C`. В простейших случаях, компилятор справится подставить векторные инструкции сам (см. семинар).
