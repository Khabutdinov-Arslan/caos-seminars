# Системные вызовы

Операционная система позволяет писать нам программы, не думая о железе, оперируя высокоуровненивыми абстракциями (файлы). С одной стороны это позволяет исполнять одни и те же программы на разном железе без специальных действий со стороны разработчиков. С другой, обезопашивает пользователя от некорректных программ. 

То есть, если мы хотим как-то обратиться к железу, мы не можем сделать это напрямую. Нам нужен какой-то механизм, который будет позволять делать запросы к операционной системе. Этот механизм называется системными вызовами.

> Красивая [презентация](https://courses.cs.washington.edu/courses/cse333/20wi/lectures/07/CSE333-L07-posix_20wi.pdf) на тему.

Обычно код процессором исполняется в непривилигерованном режиме. В тот момент, когда мы совершаем системный вызов, мы переходим в привилегированный режим процессора и начинем исполнять платформозависимый код, который взаимодействует с железом. Потом мы понижаем уровень привилегий и возвращаемся в user-space.

Напишем Hello World (`hello_stdlib.c`). С помощью команды `ldd` можно посмотреть зависимости программы и увидеть в них `libc` (если скомпилировать с `-static`, зависимостей от динамических библиотек не будет, но вырастет размер исполняемого файла). С помощью `strace` можно увидеть, что "под капотом" вызывается системный вызов `write`.

Теперь будем обходиться без `glibc`. Точкой входа в программу будет метка `_start`. Для корректного завершения нужно будет воспользоватся системным вызовом `exit`.

Родным для архитектуры x86-64 соглашением в Linux является использование команды процессора `syscall`, где номер системного вызова передается через `rax` (используйте константы из `sys/syscalls.h` для читабельности), а аргументы передаются через регистры: `rdi`, `rsi`, `rdx`, `r10`, `r8` и `r9`. Обратите внимание, что не все используемые регистры совпадают со стандартным соглашением о вызовах в x86-64, например, вместо регистра `rcx` используется регистр `r10`. 
Поэтому когда мы вызываем `write` в C, эта функция правильно перекладывает аргумент и потом совершает системный вызов. Реализовать подобный механизм можно и самому (см. `syscall.S`). Кроме того, использование команды `syscall` может испортить содержимое регистров `rcx` и `r11`. Пример использования можно посмотреть в `hello_nostdlib.c` (и аналогичный пример на ASM `hello_nostdlib.S`).

Выделять память на куче можно с помощью системного вызова `brk`. 

```
int brk(void *addr);
```

Устанавливает указатель на вершину кучи `addr`. Если передать 0, то возвращает указатель на текущую вершину. Поэтому обычно сначала получают текущий адрес, прибавляют к нему размер выделяемое памяти и вызывают `brk` повторно. Пример можно посмотреть в `brk_demo.c`.
