# ARM ассемблер

Теперь поговорим про ARM ассемблер (конкретнее, про AArch64). Процессоры на базе архитектуры ARM устанавливаются в компьютеры Apple, а также большинство портативной электроники (смартфонов, планшетов и так далее). Архитектура ощутимо эффективнее x86, поэтому многие считают, что за ним будущее.

## Настройка окружения

Про настройку окружения можно почитать в [ридинге Яковлева](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/aarch64#%D0%BA%D1%80%D0%BE%D1%81%D1%81-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC-%D0%BD%D0%B0-x86).

От себя добавлю, что удобно в `~/.bashrc` дописать алиасы наподобие

```
alias agcc='/opt/aarch64-gcc/bin/aarch64-linux-gnu-gcc'
alias agdb='/opt/aarch64-gcc/bin/aarch64-linux-gnu-gdb'
alias aobjdump='/opt/aarch64-gcc/bin/aarch64-linux-gnu-objdump'
alias arun='qemu-aarch64 -L /opt/aarch64-sysroot'
```

## Регистры и соглашения о вызовах

В `armv8` есть 31 64-битный регистр общего назначения, доступных программно: `x0`, `x1`,  ... , `x30`. Через `w0`, `w1`, ..., `w30` можно обращаться к младшим 32 битам этих регистров. 

В системе Linux предусмотрены следующие соглашения об использовании регистров:

| Регистры        | Назначение                                                   |
| --------------- | ------------------------------------------------------------ |
| `x0` ... `x7`   | аргументы функции и возвращаемое значение (`x0`)             |
| `x8` ... `x18`  | временные регистры, для которые не гарантируется сохранение результата, если вызывать какую-либо функцию |
| `x19` ... `x28` | регистры, для которых гарантируется, что вызываемая функция их не будет портить |
| `x29`           | указатель на границу фрейма функции, обычно используется отладчиком |
| `x30`      | адрес возврата из функции                                    |
| `sp`      | указатель на вершину стека                                   |

Команда `mov a b` копирует в регистр `a` данные из регистра `b`. Для работы с памятью, в отличии от `x86_64`, предусмотрены специальные инструкции `ldr/str register [address]`. Первая загружает данные в регистр, а вторая в память. Как и в случае `mov` в `x86_64`, для оперирования числами меньшего размера есть специальные суффиксы: `ldrb` загружает `uint8_t`, `ldrsb` загружает `int8_t` и так далее (суффикс `h` используется для 2 байтов, `w` для 4 байтов). Пример использования можно посмотреть в `arr_get.S`.

## Арифметические команды

Ещё в нашем минимальном примере можно увидеть некоторые арифметические команды. У большинства из них вид `command res, left, right`. Этот синтаксис означает `res = left + right` где `+` -- произвольная операция: `add`, `sub`, `mul`, `and`, `orr` и так далее. Довольно полезная инструкция `madd res, mleft, mright, anum` делает `mres=mleft*mright+anum`.

> Больше вам скорее всего не понадобится, но можно почитать в [ридинге Яковлева](https://github.com/victor-yacovlev/fpmi-caos/blob/master/practice/aarch64/README.md#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%B8-%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8), если интересно.

## Метки и переходы

Аналогично `x86_64` можно создавать метки и переходить по ним. Для безусловного подхода предназначена команда `b label`. Команда `cmp` также сравнивает числа и выставляет специальные флаги.

Если хочется сэмулировать поведение стека вызовов, нужно использовать `bl label`. Тогда адрес возврата (регистр `x30`) будет перезаписан следующей за `bl` инструкцией (но в этом случае надо не забыть сохранить исходный адрес возврата). На основе этих флагов работают суффиксы, которые можно дописать к команде `b`:

* `eq`, `ne` (равно, неравно)
* `lt`, `le`, `gt`, `ge` (меньше, меньше или равно и т.д. для знаковых чисел)

Пример использования можно посмотреть в `sum_n.S`.

## Вызов функций

Для вызова функций есть команда `bl label`. Она кладёт в `x30` адрес следующей команды. При этом нужно не забыть сохранить исходный адрес возврата (например на стек). Для выхода из функции предназначена команда `ret`. Обратите внимание, что встроенных команд `push/pop` в `aarch64` нет, но можно реализовать их самим с помощью макросов. Пример можно посмотреть в `int_echo.S`.
