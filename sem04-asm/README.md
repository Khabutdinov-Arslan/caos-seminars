# x86_64 asm

Настало время погрузиться на более низкий уровень. Будем учиться писать на ассемблере.

## Дизассемблирование

Один из способов изучения ассемблера - посмотреть на то, какой код на нем генерирует компилятор. В частности, можно дизассемблировать даже бинарные файлы. Скомпилируем простую программу из `sum.c` и посмотрим на вывод дизассемблера `objdump -M intel intel-mnemonic -d sum.out`. Дополнительные параметры отвечают за вывод в синтаксисе intel, потому что его предпочитает автор.

> Удобный инструмент для анализа вывода компиляторов [Godbolt](https://godbolt.org/).

Можно заметить, что программа на ассемблере состоит из каких-то команд. Они кодируются разным количество байт, то есть `x86_64` является `CISC (complex instruction set computing)` архитектурой. Аргументы вида `rax`, `eax` и подобные это имена регистров - ячеек памяти процессора, квадратные скобки  означают обращения по адресу в оперативной памяти (аналог разименования указателей).

## Регистры и соглашения о вызовах

В `x86_64` предусмотрены следующие соглашения об использовании регистров:

| Регистры        | Назначение                                                   |
| --------------- | ------------------------------------------------------------ |
| `rax`   | возвращаемое значение функции         |
| `rdi, rsi, rdx, rcx, r8, r9` | аргументы функции, последующие кладутся на стек |
| `rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11`  | временные регистры, для которые не гарантируется сохранение результата, если вызывать какую-либо функцию |
| `rbx, rsp, rbp, r12, r13, r14, r15` | регистры, для которых гарантируется, что вызываемая функция их не будет портить |
| `rbp`           | указатель на границу фрейма функции, обычно используется отладчиком |
| `rsp`      | указатель на вершину стека                                   |

Обращаться к младшим 32 битам можно заменяя `r` на `e` (например `eax`) в начале имени регистра или дописывая `d` в случае номерных (например `r13d`).

`mov register [base + index * scale + offset]` позволяет загрузить значение в регистр из памяти. Также можно записать значение в память из регистра или из регистра в регистр. Обратите внимание, что такой синтаксис крайне удобен для работы с массивами (пример использования можно посмотреть в `arr_get.S`).

Для загрузки в регистры чисел меньшей размерности служат суффиксы. Например, `movsxd` позволяет загружать знаковые 32-битные числа.

## Арифметические команды

Общий вид команд: `CMD left, right` отвечает за операцию `left*=right`. Например: `ADD r8, r9` прибавляет к значению регистра `r8` значения регистра `r9`.

```
add     DST, SRC        /* DST += SRC */
sub     DST, SRC        /* DST -= SRC */
inc     DST             /* ++DST */
dec     DST             /* --DST */
neg     DST             /* DST = -DST */
mov     DST, SRC        /* DST = SRC */
imul    SRC             /* (eax,edx) = eax * SRC - знаковое */
mul     SRC             /* (eax,edx) = eax * SRC - беззнаковое */
and     DST, SRC        /* DST &= SRC */
or      DST, SRC        /* DST |= SRC */
xor     DST, SRC        /* DST ^= SRC */
not     DST             /* DST = ~DST */
cmp     DST, SRC        /* DST - SRC, результат не сохраняется, */
test    DST, SRC        /* DST & SRC, результат не сохраняется  */
adc     DST, SRC        /* DST += SRC + CF */
sbb     DST, SRC        /* DST -= SRC - CF */
```

## Метки и переходы

Можно создавать метки и переходить по ним. Для безусловного перехода служит команда `jmp`. Для сравнения используется команда `cmp`. Она выставляет флаги, результаты которых можно использовать в командах для условных переходов:

```
jz      label   /* переход, если равно (нуль), ZF == 1 */
jnz     label   /* переход, если не равно (не нуль), ZF == 0 */
jc      label   /* переход, если CF == 1 */
jnc     label   /* переход, если CF == 0 */
jo      label   /* переход, если OF == 1 */
jno     label   /* переход, если OF == 0 */
jg      label   /* переход, если больше для знаковых чисел */
jge     label   /* переход, если >= для знаковых чисел */
jl      label   /* переход, если < для знаковых чисел */
jle     label   /* переход, если <= для знаковых чисел */
ja      label   /* переход, если > для беззнаковых чисел */
jae     label   /* переход, если >= (беззнаковый) */
jb      label   /* переход, если < (беззнаковый) */
jbe     label   /* переход, если <= (беззнаковый) */
```

Пример реализации цикла можно найти в `sum_n.S`.

## Стек и вызов функций


![Stack](stack_x64.png)

Переход по метке функции осуществляется командой `call label_name`, которая кладёт адрес возврата на стек, подменяет его на следующую команду после `call` и передаёт управление функции. Для выхода из функции служит команда `ret`. Пример использования функций стандартной библиотеки можно найти в `int_echo.S`.

На картинке можно видеть, что после адреса возврата лежит RBP. Во времена 32-битных систем стандартом было поддеживать текущий stack frame. Первое, что делалось внутри функции при вызове -- сохранение прошлого начала стека. Следующая конструкция называлась прологом:

```
push rbp
mov rbp, rsp
```

В конце функции принят был эпилог

``
mov rsp, rbp
pop rbp
``

Сейчас это необязательно, потому что компилятор в состоянии высчитать все адреса от вершины стека. Но вам самим в коде может быть удобно адресовать локальные переменне от RBP, потому что RSP менятся.

## Векторные регистры

В 80-е годы операции с вещественным числами исполнялись на отдельном сопроцессоре x87. У него был свой стек и набор инструкций. Сейчас же вычисления с плавающей точкой выполняются самим процессором над регистрами семейств SSE (128 бит)/AVX (256 бит)/AVX-512 (512 бит). Называются они `xmm0-15`, `ymm` и `zmm` соответственно. `xmm0` соответсвует младшим 128 битам `ymm0` и так далее.

## Скалярные инструкции

Векторные регистры можно использовать для операций с одиночными вещественными числами. Команды похожи на обычные арифметические. Буква `s` на конце означает, что операция над `float`, буква `d`, что над `double`. Есть также операции для конвертации и сравнения.

```
// Копирование регистр-регистр и регистр-память
movsd   DST, SRC  // пересылка double
movss   DST, SRC  // пересылка float

// Арифметические
addsd   DST, SRC   // DST += SRC, double
addss   DST, SRC   // DST += SRC, float
subsd   DST, SRC   // DST -= SRC, double
subss   DST, SRC   // DST -= SRC, float
mulsd   DST, SRC   // DST *= SRC, double
mulss   DST, SRC   // DST *= SRC, float
divsd   DST, SRC   // DST /= SRC, double
divss   DST, SRC   // DST /= SRC, float
sqrtsd  DST, SRC   // DST = sqrt(SRC), double
sqrtss  DST, SRC   // DST = sqrt(SRC), float
maxsd   DST, SRC   // DST = max(DST, SRC), double
maxss   DST, SRC   // DST = max(DST, SRC), float
minsd   DST, SRC   // DST = min(DST, SRC), double
minss   DST, SRC   // DST = min(DST, SRC), float

// Преобразования
cvtsd2si DST, SRC  // double -> int
cvtsi2sd DST, SRC  // int -> double

// Сравнения (операция DST-SRC, которая меняет флаги)
comisd  DST, SRC  // для double
comiss  DST, SRC  // для float
```

Вещественные аргументы в функцию передаются в `xmm0-xmm7`, значение возвращается в `xmm0`.

Пример вычисления `exp(x)` с помощью ряда Тейлора можно посмотреть в `exp.S`.

## Векторные инструкции

Также можно оперировать с векторными регистрами как с массивом из нескольких чисел. В случае `AVX` можно, например, сложить 8 вещественных чисел за одну операцию и, таким образом, получить кратный прирост производительности.

Команды имеют вид `v(operation_name)p[s|d]`:
* `v` означает, что команда оперирует векторным регистром
* `p` означает, что в нём упаковано несколько значений
* `s` означает `float`, `d` означает `double`

Например: `vaddps dst, src1, src2`.

Для загрузки значений служит: `vmov[a|u]p[s|d]`. `a` означает, что память выровнена по размеру векторного регистра (выделить такую память можно, например, с помощью `aligned_alloc`).

Пример сложения двух векторов с помощью `AVX` инструкций можно посмотреть в `add.S`.

## Горизонтальная сумма

Мы научились складывать числа в массиве блоками по несколько штук. В конце у нас в регистре лежат несколько чисел, мы хотим их сложить, чтобы получить итоговую сумму. Есть много способов это сделать. Один из наиболее коротких использует инструкции [vperm2f128](https://www.felixcloutier.com/x86/vperm2f128) и [haddps](https://www.felixcloutier.com/x86/haddps).

```
// ymm1 [x1, x2, ..., x8]
vperm2f128 ymm1, ymm0, ymm0, 1
// ymm0 [... x1, x2, x3, x4]
haddps xmm0, xmm1
// xmm0 [x1 + x2, x3 + x4, x5 + x6, x7 + x8]
haddps xmm0, xmm0
// xmm0 [x1 + x2 + x3 + x4, x5 + x6 + x7 + x8, ...]
haddps xmm0, xmm0
// xmm0 [x1 + ... + x8, ...]
```

## Intrinsics

Чтобы использовать векторные инструкции в программах на `C`, есть специальные обёртки, называемые `intrinsics`.

```
for (int i = 0; i < n; i+= 8) {
    __m256 r1 = _mm256_load_ps(a + i);
    __m256 r2 = _mm256_load_ps(b + i);
    __m256 r3 = _mm256_add_ps(r1, r2);
    _mm256_store_ps(&c[i], r3);
}
```

Здесь `__m256` на самом деле не переменная. Этот код развернётся в загрузку значения в регистр (можно проверить с помощью Godbolt).

Пример сложения двух векторов с `intrinsics` можно посмотреть в `add_int.c`.

Справочник по `intrinsics`: [Intel Intrinsics Guide](https://www.laruence.com/sse/#).
