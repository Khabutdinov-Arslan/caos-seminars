# ARM ассемблер

Настало время погрузится на более низкий уровень. Следующие несколько занятий мы будем учиться писать на ассемблере. Начнём с ARM, потому что за ним будущее.

## Настройка окружения

Про настройку окружения можно почитать в [репозитории курса](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/aarch64#%D0%BA%D1%80%D0%BE%D1%81%D1%81-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC-%D0%BD%D0%B0-x86).

От себя добавлю, что удобно в `~/.bashrc` дописать алиасы наподобие

```
alias agcc='/opt/aarch64-gcc/bin/aarch64-linux-gnu-gcc'
alias agdb='/opt/aarch64-gcc/bin/aarch64-linux-gnu-gdb'
alias aobjdump='/opt/aarch64-gcc/bin/aarch64-linux-gnu-objdump'
alias arun='qemu-aarch64 -L /opt/aarch64-sysroot'
```

## Кодирование

Скомпилируем простой пример `sum_demo.c` и посмотрим на него под `objdump -d`. Можно заметить, что программа распалась на какое-то количество простых инструкций. Каждая из них кодируется 4 байтами.

TODO: Разобраться ещё раз с opcodes, у меня что-то не сходится.

## Регистры

В основном процессор оперирует с регистрами -- специальными ячейками памяти внутри него. Соотвественно периодически приходится гонять данные в оперативную память и обратно.

У armv8 есть 31 64-битный регистр общего назначения, доступных программно: `x0`, `x1`,  ... , `x30`. Через `w0`, `w1`, ..., `w30` можно обращаться к младшим 32 битам этих регистров. 

В системе Linux предусмотрены следующие соглашения об использовании регистров:

| Регистры        | Назначение                                                   |
| --------------- | ------------------------------------------------------------ |
| `x0` ... `x7`   | аргументы функции и возвращаемое значение (`x0`)             |
| `x8` ... `x18`  | временные регистры, для которые не гарантируется сохранение результата, если вызывать какую-либо функцию |
| `x19` ... `x28` | регистры, для которых гарантируется, что вызываемая функция их не будет портить |
| `x29`           | указатель на границу фрейма функции, обычно используется отладчиком |
| `x30`      | адрес возврата из функции                                    |
| `sp`      | указатель на вершину стека                                   |

Итак, чтобы гонять данные между памятью и регистрами, нужны специальные комманды.

За загрузку в регистр отвечает команда ``ldr``.
Общий вид синтаксиса у неё следующий: ``ldr register [adress]``

Для выгрузки значений обратно в память служит команда ``str``.
Синтаксис аналогичен.

Как загрузить числа меньшие 64 бит? Есть специальные суффиксы. 
`ldrb` загружаем `uint8_t`, `ldrsb` загружает `int8_t` и так далее. Обратите внимание, что команды разные, потому что в регистре хранится число его размерности. Соответсвенно, для беззнаковых чисел просто дописываются в начало 0, для знаковых процесс чуть сложнее, чтобы удовлетворить условиям обратного кодирования.

Ещё одна крайне полезная команда `mov a b` копирует данные в регистр `a` из регистра `b` (вместо `b` также можно написать некоторую числовую константу). Пример использования этих команд можно посмотреть в `arr_get.S`.


## Арифметические команды

Ещё в нашем минимальном примере можно увидеть некоторые арифметические команды. У большинства из них вид `command res, left, right`. Этот синтаксис означает `res = left + right` где `+` -- произвольная операция. В примере можно увидеть команды `add` и `sub`. Список ещё некоторых операций:

* `mul`
* `and`
* `orr` (or)
* `eor` (xor)

> Больше вам скорее всего не понадобится, но можно почитать в [ридинге Яковлева](https://github.com/victor-yacovlev/fpmi-caos/blob/master/practice/aarch64/README.md#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%B8-%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8), если интересно.

## Метки и написание функций

Для начала научимся писать отдельные функции. В исходнике на `C` функцию нужно определить `extern` (см. `sum_main.c`), пообещав таким образом, что её объявление будет доступно в момент линковки. Сам пример функции с комментариями см. в `sum_fun.c`. Если в конце метки нет никаких переходов, исполнение просто проваливается вниз по тексту программы на следующую метку.

Чтобы перейти на другую метку используется команда `b label`.

Если хочется сэмулировать поведение стека вызовов, нужно использовать `bl label`. Тогда адрес возврата (регистр `x30`) будет перезаписан следующей за `bl` инструкцией.

У процессора есть некоторые дополнительные флаги, которые команды могут перезаписывать. Например, это делает команда `cmp left, right`

* `eq`, `ne` (равно, неравно)
* `lt`, `le`, `gt`, `ge` (меньше, меньше или равно, ...)

Чтобы получить условный переход, нужно дописать к команде `b` суффиксом соответствующий флаг. Например: `beq label`. Для примера посмотрим на функцию вычисления суммы от 1 до n (`sum_n.S`).
