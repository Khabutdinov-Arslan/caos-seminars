# Векторные регистры

В 80-е годы операции с вещественной точки исполнялись на отдельном процессоре x87. У него был свой стек и набор инструкций. Сейчас же вычисления с плавающей точкой выполняются самим процессором над регистрами семейств SSE (128 бит)/AVX (256 бит)/AVX-512 (512 бит). Называются они `xmm0-15`, `ymm` и `zmm` соответственно. `xmm0` соответсвует младшим 128 битам `ymm0` и так далее.

## Скалярные инструкции

Векторные регистры можно использовать для операций с одиночными вещественными числами. Команды похожи на обычные арифметические. Буква `s` на конце означает, что операция над `float`, буква `d`, что над `double`. Есть также операции для конвертации и сравнения.

```
// Копирование регистр-регистр и регистр-память
movsd   DST, SRC  // пересылка double
movss   DST, SRC  // пересылка float

// Арифметические
addsd   DST, SRC   // DST += SRC, double
addss   DST, SRC   // DST += SRC, float
subsd   DST, SRC   // DST -= SRC, double
subss   DST, SRC   // DST -= SRC, float
mulsd   DST, SRC   // DST *= SRC, double
mulss   DST, SRC   // DST *= SRC, float
divsd   DST, SRC   // DST /= SRC, double
divss   DST, SRC   // DST /= SRC, float
sqrtsd  DST, SRC   // DST = sqrt(SRC), double
sqrtss  DST, SRC   // DST = sqrt(SRC), float
maxsd   DST, SRC   // DST = max(DST, SRC), double
maxss   DST, SRC   // DST = max(DST, SRC), float
minsd   DST, SRC   // DST = min(DST, SRC), double
minss   DST, SRC   // DST = min(DST, SRC), float

// Преобразования
cvtsd2si DST, SRC  // double -> int
cvtsi2sd DST, SRC  // int -> double

// Сравнения (операция DST-SRC, которая меняет флаги)
comisd  DST, SRC  // для double
comiss  DST, SRC  // для float
```

Вещественные аргументы в функцию передаются в `xmm0-xmm7`, значение возвращается в `xmm0`.

Пример вычисления `exp(x)` с помощью ряда Тейлора можно посмотреть в `exp.S`.

## Векторные инструкции

Также можно оперировать с векторными регистрами как с массивом из нескольких чисел. В случае `AVX` можно, например, сложить 8 вещественных чисел за одну операцию и, таким образом, получить кратный рост производительности.

Команды имеют вид `v(operation_name)p[s|d]`:
* `v` означает, что команда оперирует векторным регистром
* `p` означает, что в нём упаковано несколько значений
* `s` означает `float`, `d` означает `double`

Например: `vaddps dst, src1, src2`.

Для загрузки значений служит: `vmov[a|u]p[s|d]`. `a` означает, что память выровнена по размеру векторного регистра (выделить такую память можно, например, с помощью `aligned_alloc`).

Пример сложения двух векторов с помощью `AVX` инструкций можно посмотреть в `add.S`.

## Горизонтальная сумма

Мы научились складывать числа в массиве блоками по несколько штук. В конце у нас в регистре лежат несколько чисел, мы хотим их просуммировать, чтобы получить итоговую сумму. Есть много способов это сделать. Один из наиболее коротких использует инструкции `vperm2f128` и `vhaddps`.

```
// ymm2 = [x7,x6,x5,x4,x3,x2,x1,x0]
vxorps  ymm0, ymm0, ymm0 // clean using XOR method
vperm2f128 ymm0, ymm2, ymm2, 0b10000001 // ymm0 = [0,0,0,0,x4,x7,x6,x5]
vhaddps ymm0, ymm0, ymm2
vhaddps ymm0, ymm0, ymm0
vhaddps ymm0, ymm0, ymm0
```

## Intrinsics

Чтобы использовать векторные инструкции в программах на `C`, есть специальные обёртки, называемые `intrinsics`.

```
for (int i = 0; i < n; i+= 8) {
    __m256 r1 = _mm256_load_ps(a + i);
    __m256 r2 = _mm256_load_ps(b + i);
    __m256 r3 = _mm256_add_ps(r1, r2);
    _mm256_store_ps(&c[i], r3);
}
```

Здесь `__m256` на самом деле не переменная. Этот код развернётся в загрузку значения в регистр (можно проверить с помощью Godbolt).

Пример сложения двух векторов с `intrinsics` можно посмотреть в `add_int.c`.

Справочник по `intrinsics`: [Intel Intrinsics Guide](https://www.laruence.com/sse/#).
