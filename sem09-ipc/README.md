# Межпроцессное взаимодействие

## Дублирование файловых дескрипторов

Для того, чтобы копировать файловые дескрипторы, есть 2 системных вызова: `dup` и `dup2`.

```
/* Возвращает копию нового файлового дескриптора, при этом, по аналогии
   с open, численное значение нового файлового дескриптора - минимальный
   не занятый номер. */
int dup(int old_fd);

/* Создаёт копию нового файлового дескриптора с явно указанным номером new_fd и в случае успеха его возвращает.
   Если ранее файловый дескриптор new_fd был открыт, то закрывает его. */
int dup2(int old_fd, int new_fd);
```

С помощью `dup2` можно сделать, например, перенаправление вывода нашей программы в файл (см. `freopen.c`).

А если скомбинировать его с `fork` и `exec`, можно перенаправлять вывод произольной программ в файл (см. `redirect.c`).

## Неименованные каналы

Канал -- это пара связанных между собой файловых дескрипторов, один из которых предназначен для только для чтения, а другой -- только для записи.
```
/* Создаёт канал и записывает файловый дескриптор читающего конца в 0 элемент массива, а пишущего -- в 1. */
int pipe(int pipefd[2]);
```

Канал буферизован, размер буффера, как правило, 65K. Запись происходит в буфер, если в нём не хватает места, то блокируемся. Если при этом читающий конец закрыт, `write` завершится с ошибкой `Broken pipe`. При чтении если буфер непуст, читаем из него, иначе блокируемся. Если пишущий конец закрыт, `read` вернёт 0.

Используя `pipe` можно перенаправить вывод произвольной программы себе на ввод (см. `pipe.c`). Если закомментировать в этом примере 23 строку, то программа зависнет. Почему?

## Именованные каналы

Для взаимодействия неродственных процессов можно использовать именованные каналы `FIFO`.

```
/* Создаёт файл канала по заданому пути и с задаными флагами доступа */
int mkfifo(const char *pathname, mode_t mode);
```

После создания такой канал можно открыть как обычный файл, но с режимом только на чтение или только на запись. Перед началом использования именного канала и пишущий, и читающий концы должны быть открыты. В остальном отличий от обычных каналов нет (пример использования можно увидеть в `fifo.c`).

## Сигналы

Сигнал -- короткое сообщение для межпроцессорного взаимодействия. Используются для прерывания/остановки процессов. 

> Прерывания генерируются железом (например MMU может генерировать Page Fault) и обрабатываются ядром. А сигналы генерируются ядром и обрабатываются процессами.

Список всех сигналов можно посмотреть в `man 7 signal`. Вот нескольких основных:

| Сигнал  | Сочетание клавиш | Значение                                     |
|---------|------------------|----------------------------------------------|
| SIGINT  | Ctrl-C           | Завершение процесса с терминала              |
| SIGSTOP | Ctrl-Z           | Перевод процесса в STOPPED                   |
| SIGTERM |                  | Просьба процессу завершиться                 |
| SIGKILL |                  | Моментальное завершение процесса             |
| SIGQUIT | Ctrl-\           | Моментальное завершение процесса с терминала |

При получении сигнала процесс может:
* Выполнить действие по-умолчанию (для всех сигналов кроме `SIGCHLD` и `SIGUSR` это завершение)
* Игнорировать сигнал
* Выполнить заданное действие

## Отправка сигналов

Отправка сигналов осуществляется системным вызовом `kill`.

``
int kill(pid_t pid, int signum);
``

Если `pid=-1`, сигнал отправится всем процессам пользователя.

С помощью `alarm` можно отправить самому себе `SIGALARM` через несколько секунд.

```
unsigned int alarm(unsigned int seconds);
```

Пример можно посмотреть в `alarm_demo.c`. Обратите внимание, что рограма завершилась не с кодом 1, а в результате прихода сигнала, потому что мы не определили обработчик.

## Обработка сигналов

Современный способ устанавливать обработчик сигналов -- системный вызов `sigaction`.

**Обработку SIGSTOP и SIGKILL переопределить нельзя**

```
int sigaction(int signum,
              const struct sigaction *restrict act,
              struct sigaction *oldact);
// В oldact запишется текущий обработчик, можно передать NULL
```

Основные поля `sigaction`:

* `sa_handler` - указатель на функцию-обработчик с одним аргументом `int signum`
* `sa_flags` - флаги. Самый полезный, `SA_RESTART` продолжает выполнение системных вызовов после исполнения обработчика. 
* `sa_sigaction` - указатель на обработчик с тремя аргументами `int signum, siginfo_t *info, void *context`. Чтобы использовать его, а не `sa_handler`, нужно проставить флаг `SA_SIGINFO`.
* `sa_mask` - маска заблокированных сигналов на время исполнения обработчика. Про маски см. далее.

## Асинхронность

Сигнал может прийти процессу в любой момент. при этом исполнение текущего кода будет прервано и будет запущен обработчик сигнала. Поэтому актуальна проблема "гонок". В обработчиках нужно использовать специальный тип `sig_atomic_t`, он "атомарен относительно обработки сигналов" при операциях чтения и записи. Также нужно добавить в определение `volatile`, чтобы запретить некоторые типы оптимизаций. Например, если есть цикл и флаг выставляется в обработчике сигнала, компилятор может соптимизовать его в `while (true)`.

```
int quit = 0;
while (!quit)
{

}
```

Также нельзя использовать не потокобезопасные функции такие как `printf` (список безопасных есть в `man 7 signal-safety`).

Обработку сигнала может прервать другой сигнал. Поэтому нужно делать максимально простые обработчики. Например, выставить флаг типа `sig_atomic_t` и как-то обработать его в цикле в основном коде (см. `sigaction_demo.c`).

## Маски сигналов

Сигналы, ожидающие доставки, представляются в виде маски т. е. их количество не учитывается. Маска своя для каждого потока. Рекомендуемые паттерн в многопоточных программах: выделить под обработку сигналов отдельный поток, а в остальных заблокировать их доставку через `pthread_sigmask`.

Есть и вторая маска -- маска заблокированных сигналов. Если придёт заблокированный сигнал, он будет обработан только после того, как пропадёт из маски заблокированнных.


Маски  сигналов описываются типом данных `sigset_t`.

Операции над маской:
 * `sigemptyset(sigset_t *set)` - инициализировать пустое множество;
 * `sigfillset(sigset_t *set)` - инициализировать полное множество;
 * `sigaddset(sigset_t *set, int signum)` - добавить сигнал к множеству;
 * `sigdelset(sigset_t *set, int signum)` - убрать сигнал из множества;
 * `sigismember(sigset_t *set, int signum)` - проверить наличие сигнала в множестве.

Можно поменять маску заблокированных сигналов с помощью `sigprocmask`:

```
int sigprocmask(int how, sigset_t *set, sigset_t *old_set);
```

Пример работы в `sigprogmask_demo.c`.

Параметр `how` - это одно из значений:
 * `SIG_SETMASK` - установить множество сигналов в качестве маски блокируемых сигналов;
 * `SIG_BLOCK` - добавить множество к маске блокируемых сигналов;
 * `SIG_UNBLOCK` - убрать множество из маски блокируемых сигналов.

Системный вызов `pause()` позволяет приостановить выполнение до прихода любого незаблокированного сигнала.

Системный вызов `sigsuspend(sigset_t *temp_mask)` временно приостанавливает работу программы до тех пор, пока не придёт один из сигналов, отсутсвующий в множестве `temp_mask`. Сигналы, отсутсвующие в новом временном множестве, будут доставлены даже в том случае, если они ранее были заблокированы (см. `sigsuspend_demo.c`).

В качестве альтернативы, можно использовать `int sigwaitinfo(const sigset_t *set, siginfo_t *info)`. Он приостанавливает программу до того, как придёт сигнал из маски (его нужно предварительно заблокировать через `sigprocmask`).  Функция возвращает номер сигнала, более подробную информацию можно получить из структуры.

## Сигналы реального времени

Сигналы раннего времени имеют номера от `SIGRTMIN` до `SIGRTMAX` и доставляются через очередь, поэтому учитывается их количество и порядок прихода. Также есть одно дополнительное поле для передачи целочисленной информации.


Для использования очереди сигналов, необходимо отправлять их с помощью функции `sigqueue`:

```
#include <signal.h>
union sigval {
    int    sival_int;
    void*  sival_ptr;
};
int sigqueue(pid_t pid, int signum, const union sigval value);
```

Эта функция может завершиться с ошибкой `EAGAIN` в том случае, если исчерпан лимит на количество сигналов в очереди. Опциональное значение, передаваемое в качестве третьего параметра, может быть извлечено получателем из поля `si_value` структуры `siginfo_t`, если использовать вариант обработчика `sigaction` с тремя аргументами. Пример использования можно посмотреть в `sigqueue_demo.c`.

## signalfd

В Linux есть способ обрабатывать сигналы через специальный файловый дескриптор.

```
int signalfd(int fd, const sigset_t *mask, int flags);
// fd позволяет заменить существующий файловый дескриптор (-1 если хотим просто открыть новый)
// маска отвечает за сигналы, которые мы хотим получать
// нужно их предварительно заблокировать через sigprocmask
// чтобы отключить обработку по-умолчанию
```

После этого можно читать из возвращённого файлового дескриптора структуру `signalfd_siginfo`. Список всех полей можно посмотреть в `man 2 signalfd`. Наиболее полезные:
* `ssi_signo` - номер сигнала
* `ssi_pid` - PID отправителя
* `ssi_int` - переданное число (для сигналов реального времени)

**Ограничения**: нельзя обрабатывать сигналы, которые генерируются синхронно, такие как `SIGSEGV` и `SIGFPE`.

Пример использования можно посмотреть в `signalfd_demo.c`.

> Можно при помощи пайпов реализовать свой платформо-независимый аналог `signal_fd`. 
Про это почитать можно [тут](https://github.com/yuri-pechatnov/caos/tree/master/caos_2020-2021/sem15-signal#-signalfd-%D0%B4%D0%BB%D1%8F-%D0%B1%D0%B5%D0%B4%D0%BD%D1%8B%D1%85).

## timerfd

Можно работать с таймерами через специальный файловый дескриптор. Сначала его нужно создать:

```
int timerfd_create(int clockid, int flags);
// clock_id тип часов, CLOCK_MONOTIC наиболее часто используемый
```

После этого, можно установить параметры таймера с помощью структуры `itimerspec`.

```
struct timespec {
    time_t tv_sec;
    long   tv_nsec;
};
struct itimerspec {
    struct timespec it_interval; // интервал
    struct timespec it_value; // первое срабатывание
};
```

```
int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);
// Чтобы установить таймер, одно из полей it_value должно быть не 0
// Чтобы сбросить, оба поля должны быть равны 0
// Возвращает 0 или -1 и проставляет errno
```

Можно получить параметры таймера по файловому дескриптору:

```
int timerfd_gettime(int fd, struct itimerspec *curr_value);
```

Пример использования можно посмотреть в `timerfd_demo.c`.
