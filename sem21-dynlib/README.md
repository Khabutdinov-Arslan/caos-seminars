# Динамические библиотеки

## Статическая/динамическая линковка

При статической линковке библиотечный код вставляется в исполняемый файл (см. `make static`).

Можно проверить, что код функции `foo` действительно попал в `static.out` с помощью `objdump -d static.out | grep foo --after 9`.

При динамической линковке (см. `make dynamic`) код функции погдгружается в момент выполнения специальной программой `ldd`. Код библиотеки может быть загружен в произвольное место в адресном пространстве, поэтому должен быть позиционно-независимым (`fPIC`). Можно убедиться, что `dynamic.out` не содержит `foo`.

При запуске нужно указать путь для поиска динамических библиотек `LD_LIBRARY_PATH=. ./dynamic.out`.

|Статическая линковка|Динамическая линковка|
|---|---|
|Происходит во время компиляции|Происходит во время исполнения|
|Код библиотеки содержится в исполняемом файле|Код библиотеки подгружается во время исполнения|
|Больше исполняемый файл|Меньше исполняемый файл|
|Медленнее загрузка|Быстрее загрузка|
|Тяжело поддерживать|Легко обновлять|

TODO: rpath

## Трамплины

Видно, что в `dynamic.out` содержится некая функция `foo@plt`. Она указывает на некоторый адрес.  Он называется `relocation` и указывает на то, что при вызове функции нужно её загрузить и адрес записать адрес функции в `GOT`. С помощью `objdump -R dynamic.out` можно увидеть, что  самом исполняемом файле этот адрес не заполнен. Его заполнит `ldd` при запуске.

## Загрузка библиотеки с помощью dl

`void *dlopen(const char *filename, int flags)` загружает файл с библиотекой и `handle`. Наиболее важные флаги:

* `RTLD_NOW` загружает все символы и только потом выходит из `dlopen`
* `RTLD_LAZY` подгружает символы по мере вызова

`void *dlsym(void *handle, const char *symbol)` возвращает арес символа

`int dlclose(void *handle)` уменьшает счётчик использований динамического объекта. Если он становится нулём, выгружает его из памяти.

`char *dlerror()` возвращает текст ошибки, связанной с динамической загрузкой библиотек.

Пример использования см. в `loader.c`.

## Загрузка библиотеки с помощью mmap

Как мы помним из прошлых занятий, можно делать маппинги произвольных файлов в память. В частности, можно загрузить код библиотеки с правами на исполнение и вызвать его. Пример чисто игрушечный (так в жизни делать не стоит) можно найти в `mmap_loader.c`.

## Name mangling

Понадобится в ДЗ, хорошо написано у Юры: https://github.com/yuri-pechatnov/caos/tree/master/caos_2020-2021/sem23-dynamic-lib#-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%81-%D1%81
