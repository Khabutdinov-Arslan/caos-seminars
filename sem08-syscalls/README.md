# Системные вызовы

Операционная система позволяет писать нам программы, не думая о железе. Кроме того, она обезопашивает нас, не давая напрямую воздействовать на оборудование. Доступ к нему есть только у ядра. Когда мы хотим записать в файл, например, используем механизм системных вызовов, который временно повышает привелегии процесса. Красивая [презентация](https://courses.cs.washington.edu/courses/cse333/20wi/lectures/07/CSE333-L07-posix_20wi.pdf) на тему.

Напишем Hello World (`hello_stdlib.c`). С помощью команды `ldd` можно посмотреть зависимости программы и увидеть в них `libc` (если скомпилировать с `-static`, зависимостей от динамических библиотек не будет, но вырастет размер исполняемого файла). С помощью `strace` можно увидеть, что "под капотом" вызывается системный вызов `write`.

Теперь будем обходиться без `glibc`. Точкой входа в программу будет метка `_start`. Для корректного завершения нужно будет воспользоватся системным вызовом `exit`.

Родным для архитектуры x86-64 соглашением в Linux является использование команды процессора `syscall`, где номер системного вызова передается через `rax` (используйте константы из `sys/syscalls.h` для читабельности), а аргументы передаются через регистры: `rdi`, `rsi`, `rdx`, `r10`, `r8` и `r9`. Обратите внимание, что не все используемые регистры совпадают со стандартным соглашением о вызовах в x86-64, например, вместо регистра `rcx` используется регистр `r10`. Кроме того, использование команды `syscall` может испортить содержимое регистров `rcx` и `r11`. Пример использования можно посмотреть в `hello_nostdlib.c`.

TODO: brk https://github.com/yuri-pechatnov/caos/tree/master/caos_2020-2021/sem09-x86-asm-nostdlib#-%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D0%B2-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%BC-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%BC-brk

