# Потоки
 
Зачастую нам бывает нужно что-нибудь параллельно посчитать. В этом случае нам удобно иметь общую память, а для локальных вычислений достаточно своего стека и регистров (и своей обработки сигналов). В таком случае можно говорить о потоках.

Чтобы использовать потоки, нужно при компиляции добавить опцию `-pthread`. 

## Использование POSIX потоков

Запуск потоков осуществляется с помощью системного вызова `pthread_create`.

```
int pthread_create(
    // указатель на переменную-результат
    pthread_t *thread,

    // опционально: параметры нового потока,
    // например размер стека
    // может быть NULL
    const pthread_attr_t *attr,

    // функция, которая будет выполняться
    (void*)(*function)(void*),

    // аргумент, который передается в функцию
    void *arg
);
```

Дождаться завершения можно с помощью `pthread_join`.

```
int pthread_join(
    // поток, который нужно ждать
    pthread_t thread,

    // указатель на результат работы функции,
    // либо NULL, если он не интересен
    (void*) *retval
    );
```

При это `retval` должен быть на куче, потому что стек потока уничтожится после завершения функции.

Измерить ускорение от распараллеливания можно на примере `parallel_sum.c`. Заодно можно поговорить о том, что измеряет команда `time`.
* `real` считает астрономическое время с момента запуска до завершения программы
* `user` считает, сколько времени ваша программа исполнялась на CPU в обычном режиме
* `sys` считает, сколько времени ваша программа исполнялась на CPU в привелигированном режиме (например, в системных вызовах)

Можно позапускать пример на разном числе потоков и заметить, что по `real` достигается почти линейное ускорение в начале. А две других цифры не меняются, потому что объём вычислений остаётся неизменным, они просто распределяются по разным ядрам процессора. Ускорение остановится примерно в тот момент, когда число потоков сравнится с числом потоков процессора.

## Аттрибуты потоков

Если результат работы потока вам больше не нужен, можно завершить его с помощью `pthread_cancel`.

```
int pthread_cancel(
    // поток, который нужно прибить
    pthread_t thread
    );
```

Манипуляция аттрибутами потока производится путём создания структуры и вызова сеттеров.
```
pthread_attr_t thread_attr; 
pthread_attr_init(&thread_attr);
pthread_attr_setstacksize(&thread_attr, MY_STACK_SIZE);
pthread_attr_destroy(&thread_attr);
```

В контестах вам понадобится уменьшить размер стека (по-умолчанию он 8ГБ).

## Дополнительно

Можно заметить, например с помощью Godbolt, что если создать в функции мало локальных переменных, стек-пойнтер не двигается. Это потому, что под стековым кадром в функциях, которые не вызывают другие функции, под Linux есть 128 байт красной зоны, которыми можно безопасно пользоваться. Это позволяет экономить целых две ассемблерных инструкции!

Ещё под каждым стеком потока есть одна страница Guard Page. При попытке записи в неё генерируется SegFault. Это позволяет отлавливать небольшие выходы за границу стека.

Пример реализации потоков в xv6:
* create/join: https://github.com/joeylemon/xv6-threads/blob/main/ulib.c#L109
* clone: https://github.com/joeylemon/xv6-threads/blob/main/proc.c#L225
https://raw.githubusercontent.com/victor-yacovlev/fpmi-caos/master/lectures/spring-2020/Lection17-Threading.pdf

Разделенные пробелом, знаковость